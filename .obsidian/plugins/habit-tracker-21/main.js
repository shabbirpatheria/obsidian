/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HabitTracker21
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
var HtmlTag = class {
  constructor(is_svg = false) {
    /**
     * @private
     * @default false
     */
    __publicField(this, "is_svg", false);
    /** parent for creating node */
    __publicField(this, "e");
    /** html tag nodes */
    __publicField(this, "n");
    /** target */
    __publicField(this, "t");
    /** anchor */
    __publicField(this, "a");
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
};
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance4, create_fragment4, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance4 ? instance4(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment4 ? create_fragment4($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/date-fns/toDate.mjs
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return new Date(NaN);
  }
}

// node_modules/date-fns/constructFrom.mjs
function constructFrom(date, value) {
  if (date instanceof Date) {
    return new date.constructor(value);
  } else {
    return new Date(value);
  }
}

// node_modules/date-fns/addDays.mjs
function addDays(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount))
    return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  _date.setDate(_date.getDate() + amount);
  return _date;
}

// node_modules/date-fns/constants.mjs
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;
var millisecondsInWeek = 6048e5;
var millisecondsInDay = 864e5;
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;

// node_modules/date-fns/_lib/defaultOptions.mjs
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

// node_modules/date-fns/startOfWeek.mjs
function startOfWeek(date, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = (_h = (_g = (_d = (_c = options == null ? void 0 : options.weekStartsOn) != null ? _c : (_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) != null ? _d : defaultOptions2.weekStartsOn) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) != null ? _h : 0;
  const _date = toDate(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/startOfISOWeek.mjs
function startOfISOWeek(date) {
  return startOfWeek(date, { weekStartsOn: 1 });
}

// node_modules/date-fns/getISOWeekYear.mjs
function getISOWeekYear(date) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/startOfDay.mjs
function startOfDay(date) {
  const _date = toDate(date);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

// node_modules/date-fns/differenceInCalendarDays.mjs
function differenceInCalendarDays(dateLeft, dateRight) {
  const startOfDayLeft = startOfDay(dateLeft);
  const startOfDayRight = startOfDay(dateRight);
  const timestampLeft = +startOfDayLeft - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  const timestampRight = +startOfDayRight - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / millisecondsInDay);
}

// node_modules/date-fns/startOfISOWeekYear.mjs
function startOfISOWeekYear(date) {
  const year = getISOWeekYear(date);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// node_modules/date-fns/constructNow.mjs
function constructNow(date) {
  return constructFrom(date, Date.now());
}

// node_modules/date-fns/isSameDay.mjs
function isSameDay(dateLeft, dateRight) {
  const dateLeftStartOfDay = startOfDay(dateLeft);
  const dateRightStartOfDay = startOfDay(dateRight);
  return +dateLeftStartOfDay === +dateRightStartOfDay;
}

// node_modules/date-fns/isDate.mjs
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/date-fns/isValid.mjs
function isValid(date) {
  if (!isDate(date) && typeof date !== "number") {
    return false;
  }
  const _date = toDate(date);
  return !isNaN(Number(_date));
}

// node_modules/date-fns/eachDayOfInterval.mjs
function eachDayOfInterval(interval, options) {
  var _a;
  const startDate = toDate(interval.start);
  const endDate = toDate(interval.end);
  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  const currentDate = reversed ? endDate : startDate;
  currentDate.setHours(0, 0, 0, 0);
  let step = (_a = options == null ? void 0 : options.step) != null ? _a : 1;
  if (!step)
    return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }
  const dates = [];
  while (+currentDate <= endTime) {
    dates.push(toDate(currentDate));
    currentDate.setDate(currentDate.getDate() + step);
    currentDate.setHours(0, 0, 0, 0);
  }
  return reversed ? dates.reverse() : dates;
}

// node_modules/date-fns/startOfYear.mjs
function startOfYear(date) {
  const cleanDate = toDate(date);
  const _date = constructFrom(date, 0);
  _date.setFullYear(cleanDate.getFullYear(), 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options == null ? void 0 : options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};

// node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/date-fns/locale/en-US/_lib/formatLong.mjs
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];

// node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index];
  };
}

// node_modules/date-fns/locale/en-US/_lib/localize.mjs
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/date-fns/locale/_lib/buildMatchFn.mjs
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}

// node_modules/date-fns/locale/en-US/_lib/match.mjs
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// node_modules/date-fns/locale/en-US.mjs
var enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// node_modules/date-fns/getDayOfYear.mjs
function getDayOfYear(date) {
  const _date = toDate(date);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}

// node_modules/date-fns/getISOWeek.mjs
function getISOWeek(date) {
  const _date = toDate(date);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/getWeekYear.mjs
function getWeekYear(date, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const _date = toDate(date);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = (_h = (_g = (_d = (_c = options == null ? void 0 : options.firstWeekContainsDate) != null ? _c : (_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) != null ? _d : defaultOptions2.firstWeekContainsDate) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.firstWeekContainsDate) != null ? _h : 1;
  const firstWeekOfNextYear = constructFrom(date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom(date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/startOfWeekYear.mjs
function startOfWeekYear(date, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = (_h = (_g = (_d = (_c = options == null ? void 0 : options.firstWeekContainsDate) != null ? _c : (_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) != null ? _d : defaultOptions2.firstWeekContainsDate) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.firstWeekContainsDate) != null ? _h : 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom(date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}

// node_modules/date-fns/getWeek.mjs
function getWeek(date, options) {
  const _date = toDate(date);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/_lib/addLeadingZeros.mjs
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}

// node_modules/date-fns/_lib/format/lightFormatters.mjs
var lightFormatters = {
  // Year
  y(date, token) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date, token) {
    return addLeadingZeros(date.getDate(), token.length);
  },
  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros(date.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros(date.getHours(), token.length);
  },
  // Minute
  m(date, token) {
    return addLeadingZeros(date.getMinutes(), token.length);
  },
  // Second
  s(date, token) {
    return addLeadingZeros(date.getSeconds(), token.length);
  },
  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};

// node_modules/date-fns/_lib/format/formatters.mjs
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function(date, token, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token, localize2) {
    if (token === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token);
  },
  // Local week-numbering year
  Y: function(date, token, localize2, options) {
    const signedWeekYear = getWeekYear(date, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date, token) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token, localize2, options) {
    const week = getWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function(date, token, localize2) {
    const isoWeek = getISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token);
  },
  // Day of year
  D: function(date, token, localize2) {
    const dayOfYear = getDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token, localize2) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token, localize2) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date, token);
  },
  // Hour [0-23]
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token);
  },
  // Hour [0-11]
  K: function(date, token, localize2) {
    const hours = date.getHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function(date, token, localize2) {
    let hours = date.getHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token);
  },
  // Second
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token);
  },
  // Fraction of second
  S: function(date, token) {
    return lightFormatters.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token, _localize) {
    const timestamp = Math.trunc(date.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date, token, _localize) {
    const timestamp = date.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, delimiter);
}
function formatTimezone(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

// node_modules/date-fns/_lib/format/longFormatters.mjs
var dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
var timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
var dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

// node_modules/date-fns/_lib/protectedTokens.mjs
var dayOfYearTokenRE = /^D+$/;
var weekYearTokenRE = /^Y+$/;
var throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token))
    throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}

// node_modules/date-fns/format.mjs
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(date, formatStr, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const defaultOptions2 = getDefaultOptions();
  const locale = (_b = (_a = options == null ? void 0 : options.locale) != null ? _a : defaultOptions2.locale) != null ? _b : enUS;
  const firstWeekContainsDate = (_j = (_i = (_f = (_e = options == null ? void 0 : options.firstWeekContainsDate) != null ? _e : (_d = (_c = options == null ? void 0 : options.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) != null ? _f : defaultOptions2.firstWeekContainsDate) != null ? _i : (_h = (_g = defaultOptions2.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.firstWeekContainsDate) != null ? _j : 1;
  const weekStartsOn = (_r = (_q = (_n = (_m = options == null ? void 0 : options.weekStartsOn) != null ? _m : (_l = (_k = options == null ? void 0 : options.locale) == null ? void 0 : _k.options) == null ? void 0 : _l.weekStartsOn) != null ? _n : defaultOptions2.weekStartsOn) != null ? _q : (_p = (_o = defaultOptions2.locale) == null ? void 0 : _o.options) == null ? void 0 : _p.weekStartsOn) != null ? _r : 0;
  const originalDate = toDate(date);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken)
      return part.value;
    const token = part.value;
    if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token) || !(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date));
    }
    const formatter = formatters[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}

// node_modules/date-fns/getDate.mjs
function getDate(date) {
  const _date = toDate(date);
  const dayOfMonth = _date.getDate();
  return dayOfMonth;
}

// node_modules/date-fns/isToday.mjs
function isToday(date) {
  return isSameDay(date, constructNow(date));
}

// node_modules/date-fns/subDays.mjs
function subDays(date, amount) {
  return addDays(date, -amount);
}

// node_modules/date-fns/parseISO.mjs
function parseISO(argument, options) {
  var _a;
  const additionalDigits = (_a = options == null ? void 0 : options.additionalDigits) != null ? _a : 2;
  const dateStrings = splitDateString(argument);
  let date;
  if (dateStrings.date) {
    const parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }
  const timestamp = date.getTime();
  let time = 0;
  let offset;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    const dirtyDate = new Date(timestamp + time);
    const result = new Date(0);
    result.setFullYear(
      dirtyDate.getUTCFullYear(),
      dirtyDate.getUTCMonth(),
      dirtyDate.getUTCDate()
    );
    result.setHours(
      dirtyDate.getUTCHours(),
      dirtyDate.getUTCMinutes(),
      dirtyDate.getUTCSeconds(),
      dirtyDate.getUTCMilliseconds()
    );
    return result;
  }
  return new Date(timestamp + time + offset);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  const dateStrings = {};
  const array = dateString.split(patterns.dateTimeDelimiter);
  let timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(
        dateStrings.date.length,
        dateString.length
      );
    }
  }
  if (timeString) {
    const token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  const regex = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)"
  );
  const captures = dateString.match(regex);
  if (!captures)
    return { year: NaN, restDateString: "" };
  const year = captures[1] ? parseInt(captures[1]) : null;
  const century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return new Date(NaN);
  const captures = dateString.match(dateRegex);
  if (!captures)
    return new Date(NaN);
  const isWeekDate = !!captures[4];
  const dayOfYear = parseDateUnit(captures[1]);
  const month = parseDateUnit(captures[2]) - 1;
  const day = parseDateUnit(captures[3]);
  const week = parseDateUnit(captures[4]);
  const dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    const date = new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  const captures = timeString.match(timeRegex);
  if (!captures)
    return NaN;
  const hours = parseTimeUnit(captures[1]);
  const minutes = parseTimeUnit(captures[2]);
  const seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  const captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  const sign = captures[1] === "+" ? -1 : 1;
  const hours = parseInt(captures[2]);
  const minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  const date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date.getUTCDay() || 7;
  const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

// src/utils.js
var getDateAsString = function(date) {
  const dateObj = typeof date === "string" ? parseISO(date) : date;
  return format(dateObj, "yyyy-MM-dd");
};
var getDayOfTheWeek = function(date) {
  return format(parseISO(date), "EEEE").toLowerCase();
};
var debugLog = function(message2, currentDebugLevel, requiredLevel, pluginName = "Habit Tracker 21") {
  if (!currentDebugLevel)
    return null;
  if (requiredLevel && requiredLevel !== currentDebugLevel)
    return null;
  console.log(`[${pluginName}]`, message2);
};
var pluralize = function(count, singular, plural) {
  if (count === 1)
    return singular;
  return plural || singular + "s";
};
var renderPrettyDate = function(dateString) {
  const date = parseISO(dateString);
  let prettyDate = format(date, "MMMM d, yyyy");
  if (isToday(date)) {
    prettyDate = `Today, ${prettyDate}`;
  }
  return prettyDate;
};
var isValidCSSColor = function(color) {
  if (!color)
    return false;
  const tempEl = document.createElement("div");
  tempEl.style.color = color;
  return tempEl.style.color !== "";
};

// src/Habit.svelte
var import_obsidian = require("obsidian");
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_if_block(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*dates*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*getClasses, dates, entriesInRange, toggleHabit*/
      102) {
        each_value = ensure_array_like(
          /*dates*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block(ctx) {
  let div;
  let div_class_value;
  let div_ticked_value;
  let div_streak_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[15](
        /*date*/
        ctx[19]
      )
    );
  }
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = /*getClasses*/
      ctx[5](
        /*date*/
        ctx[19]
      ));
      attr(div, "ticked", div_ticked_value = /*entriesInRange*/
      ctx[2][
        /*date*/
        ctx[19]
      ].ticked);
      attr(div, "streak", div_streak_value = /*entriesInRange*/
      ctx[2][
        /*date*/
        ctx[19]
      ].streak);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = listen(div, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*getClasses, dates*/
      34 && div_class_value !== (div_class_value = /*getClasses*/
      ctx[5](
        /*date*/
        ctx[19]
      ))) {
        attr(div, "class", div_class_value);
      }
      if (dirty & /*entriesInRange, dates*/
      6 && div_ticked_value !== (div_ticked_value = /*entriesInRange*/
      ctx[2][
        /*date*/
        ctx[19]
      ].ticked)) {
        attr(div, "ticked", div_ticked_value);
      }
      if (dirty & /*entriesInRange, dates*/
      6 && div_streak_value !== (div_streak_value = /*entriesInRange*/
      ctx[2][
        /*date*/
        ctx[19]
      ].streak)) {
        attr(div, "streak", div_streak_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let div1;
  let div0;
  let a;
  let t0;
  let t1;
  let show_if = Object.keys(
    /*entriesInRange*/
    ctx[2]
  ).length;
  let if_block = show_if && create_if_block(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      a = element("a");
      t0 = text(
        /*habitName*/
        ctx[3]
      );
      t1 = space();
      if (if_block)
        if_block.c();
      attr(
        a,
        "href",
        /*path*/
        ctx[0]
      );
      attr(
        a,
        "aria-label",
        /*path*/
        ctx[0]
      );
      attr(a, "class", "internal-link");
      attr(div0, "class", "habit-tracker__cell--name habit-tracker__cell");
      attr(div1, "class", "habit-tracker__row");
      attr(
        div1,
        "style",
        /*customStyles*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, a);
      append(a, t0);
      append(div1, t1);
      if (if_block)
        if_block.m(div1, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*habitName*/
      8)
        set_data(
          t0,
          /*habitName*/
          ctx2[3]
        );
      if (dirty & /*path*/
      1) {
        attr(
          a,
          "href",
          /*path*/
          ctx2[0]
        );
      }
      if (dirty & /*path*/
      1) {
        attr(
          a,
          "aria-label",
          /*path*/
          ctx2[0]
        );
      }
      if (dirty & /*entriesInRange*/
      4)
        show_if = Object.keys(
          /*entriesInRange*/
          ctx2[2]
        ).length;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*customStyles*/
      16) {
        attr(
          div1,
          "style",
          /*customStyles*/
          ctx2[4]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let entriesInRange;
  let getClasses;
  let { app } = $$props;
  let { name } = $$props;
  let { path } = $$props;
  let { dates } = $$props;
  let { debug } = $$props;
  let { pluginName } = $$props;
  let { userSettings } = $$props;
  let { globalSettings } = $$props;
  let entries = [];
  let frontmatter = {};
  let habitName = name;
  let customStyles = "";
  let savingChanges = false;
  const findStreak = function(date) {
    let currentDate = parseISO(date);
    let streak = 0;
    while (entries.includes(getDateAsString(currentDate))) {
      streak++;
      currentDate.setDate(currentDate.getDate() - 1);
    }
    return streak;
  };
  const init2 = async function() {
    debugLog(`Loading habit ${habitName}`, debug, void 0, pluginName);
    const getFrontmatter = async function(path2) {
      const file = this.app.vault.getAbstractFileByPath(path2);
      if (!file || !(file instanceof import_obsidian.TFile)) {
        debugLog(`No file found for path: ${path2}`, debug, void 0, pluginName);
        return {};
      }
      try {
        return await this.app.vault.read(file).then((result) => {
          const frontmatter2 = result.split("---")[1];
          if (!frontmatter2) {
            return { "entries": [] };
          }
          fmParsed = (0, import_obsidian.parseYaml)(frontmatter2);
          if (fmParsed["entries"] == void 0) {
            fmParsed["entries"] = [];
          }
          return fmParsed;
        });
      } catch (error) {
        debugLog(`Error in habit ${habitName}: error.message`, debug, void 0, pluginName);
        return {};
      }
    };
    $$invalidate(14, frontmatter = await getFrontmatter(path));
    debugLog(`Frontmatter for ${path} \u21B4`, debug);
    debugLog(frontmatter, debug);
    $$invalidate(13, entries = frontmatter.entries);
    $$invalidate(13, entries = entries.sort());
    $$invalidate(3, habitName = frontmatter.title || habitName);
    debugLog(`Habit "${habitName}": Found ${entries.length} entries`, debug);
    debugLog(entries, debug, void 0, pluginName);
    app.vault.on("modify", (file) => {
      if (file.path === path) {
        if (!savingChanges) {
          console.log("oh shit, i was modified");
          init2();
        }
        savingChanges = false;
      }
    });
  };
  const toggleHabit = function(date) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!file || !(file instanceof import_obsidian.TFile)) {
      new Notice(`${pluginName}: file missing while trying to toggle habit`);
      return;
    }
    let newEntries = [...entries];
    if (entriesInRange[date].ticked) {
      newEntries = newEntries.filter((e) => e !== date);
    } else {
      newEntries.push(date);
    }
    $$invalidate(13, entries = newEntries.sort());
    savingChanges = true;
    this.app.fileManager.processFrontMatter(file, (frontmatter2) => {
      frontmatter2["entries"] = entries;
    });
  };
  init2();
  const click_handler = (date) => toggleHabit(date);
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(7, app = $$props2.app);
    if ("name" in $$props2)
      $$invalidate(8, name = $$props2.name);
    if ("path" in $$props2)
      $$invalidate(0, path = $$props2.path);
    if ("dates" in $$props2)
      $$invalidate(1, dates = $$props2.dates);
    if ("debug" in $$props2)
      $$invalidate(9, debug = $$props2.debug);
    if ("pluginName" in $$props2)
      $$invalidate(10, pluginName = $$props2.pluginName);
    if ("userSettings" in $$props2)
      $$invalidate(11, userSettings = $$props2.userSettings);
    if ("globalSettings" in $$props2)
      $$invalidate(12, globalSettings = $$props2.globalSettings);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*frontmatter, userSettings, globalSettings*/
    22528) {
      $: {
        const resolvedColor = frontmatter.color || userSettings.color || globalSettings.defaultColor;
        if (resolvedColor && isValidCSSColor(resolvedColor)) {
          $$invalidate(4, customStyles = `--habit-bg-ticked: ${resolvedColor}`);
        } else {
          $$invalidate(4, customStyles = "");
        }
      }
    }
    if ($$self.$$.dirty & /*dates, entries*/
    8194) {
      $:
        $$invalidate(2, entriesInRange = dates.reduce(
          (acc, date) => {
            const ticked = entries.includes(date);
            acc[date] = { ticked, streak: findStreak(date) };
            return acc;
          },
          {}
        ));
    }
    if ($$self.$$.dirty & /*entriesInRange, userSettings, globalSettings, dates, entries*/
    14342) {
      $:
        $$invalidate(5, getClasses = function(date) {
          let classes = [
            "habit-tracker__cell",
            `habit-tracker__cell--${getDayOfTheWeek(date)}`,
            "habit-tick"
          ];
          if (entriesInRange[date].ticked) {
            classes.push("habit-tick--ticked");
          }
          const showStreaksEnabled = userSettings.showStreaks !== void 0 ? userSettings.showStreaks : globalSettings.showStreaks;
          if (showStreaksEnabled) {
            const streak = entriesInRange[date].streak;
            if (streak) {
              classes.push("habit-tick--streak");
            }
            if (streak == 1) {
              classes.push("habit-tick--streak-start");
            }
            let isNextDayTicked = false;
            const nextDate = getDateAsString(addDays(parseISO(date), 1));
            if (date === dates.at(-1)) {
              isNextDayTicked = entries.includes(nextDate);
            } else {
              isNextDayTicked = entriesInRange[nextDate].ticked;
            }
            if (entriesInRange[date].ticked && !isNextDayTicked) {
              classes.push("habit-tick--streak-end");
            }
          }
          return classes.join(" ");
        });
    }
  };
  return [
    path,
    dates,
    entriesInRange,
    habitName,
    customStyles,
    getClasses,
    toggleHabit,
    app,
    name,
    debug,
    pluginName,
    userSettings,
    globalSettings,
    entries,
    frontmatter,
    click_handler
  ];
}
var Habit = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      app: 7,
      name: 8,
      path: 0,
      dates: 1,
      debug: 9,
      pluginName: 10,
      userSettings: 11,
      globalSettings: 12
    });
  }
};
var Habit_default = Habit;

// src/HabitTracker.svelte
var import_obsidian2 = require("obsidian");
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let div2;
  let div1;
  let div0;
  let t0;
  let t1;
  let div2_class_value;
  let current;
  let each_value_1 = ensure_array_like(
    /*state*/
    ctx[4].computed.dates
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ensure_array_like(
    /*state*/
    ctx[4].computed.habits
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "habit-tracker__cell--name habit-tracker__cell");
      attr(div1, "class", "habit-tracker__header habit-tracker__row");
      attr(div2, "class", div2_class_value = "habit-tracker " + /*state*/
      (ctx[4].settings.matchLineLength ? "habit-tracker--match-line-length" : ""));
      set_style(
        div2,
        "--date-columns",
        /*state*/
        ctx[4].computed.dates.length
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div1, t0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div1, null);
        }
      }
      append(div2, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      ctx[5](div2);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*state*/
      16) {
        each_value_1 = ensure_array_like(
          /*state*/
          ctx2[4].computed.dates
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(div1, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*state, app, pluginName, userSettings, globalSettings*/
      31) {
        each_value = ensure_array_like(
          /*state*/
          ctx2[4].computed.habits
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*state*/
      16 && div2_class_value !== (div2_class_value = "habit-tracker " + /*state*/
      (ctx2[4].settings.matchLineLength ? "habit-tracker--match-line-length" : ""))) {
        attr(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*state*/
      16) {
        set_style(
          div2,
          "--date-columns",
          /*state*/
          ctx2[4].computed.dates.length
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      ctx[5](null);
    }
  };
}
function create_if_block_1(ctx) {
  let div;
  let strong;
  let t0;
  let t1;
  let t2;
  let t3_value = (
    /*state*/
    ctx[4].settings.path + ""
  );
  let t3;
  let t4;
  return {
    c() {
      div = element("div");
      strong = element("strong");
      t0 = text("\u{1F615} ");
      t1 = text(
        /*pluginName*/
        ctx[2]
      );
      t2 = text('\n	No habits to show at "');
      t3 = text(t3_value);
      t4 = text('"');
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, strong);
      append(strong, t0);
      append(strong, t1);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*pluginName*/
      4)
        set_data(
          t1,
          /*pluginName*/
          ctx2[2]
        );
      if (dirty & /*state*/
      16 && t3_value !== (t3_value = /*state*/
      ctx2[4].settings.path + ""))
        set_data(t3, t3_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t2);
        detach(t3);
        detach(t4);
      }
    }
  };
}
function create_if_block2(ctx) {
  let div;
  let strong;
  let t0;
  let t1;
  let t2;
  let t3_value = (
    /*state*/
    ctx[4].ui.fatalError + ""
  );
  let t3;
  return {
    c() {
      div = element("div");
      strong = element("strong");
      t0 = text("\u{1F6D1} ");
      t1 = text(
        /*pluginName*/
        ctx[2]
      );
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, strong);
      append(strong, t0);
      append(strong, t1);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*pluginName*/
      4)
        set_data(
          t1,
          /*pluginName*/
          ctx2[2]
        );
      if (dirty & /*state*/
      16 && t3_value !== (t3_value = /*state*/
      ctx2[4].ui.fatalError + ""))
        set_data(t3, t3_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t2);
        detach(t3);
      }
    }
  };
}
function create_each_block_1(ctx) {
  let div;
  let t0_value = getDate(parseISO(
    /*date*/
    ctx[15]
  )) + "";
  let t0;
  let t1;
  let div_class_value;
  let div_data_ht___date_value;
  let div_data_ht___pretty_date_value;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      attr(div, "class", div_class_value = "habit-tracker__cell habit-tracker__cell--" + getDayOfTheWeek(
        /*date*/
        ctx[15]
      ));
      attr(div, "data-ht21-date", div_data_ht___date_value = /*date*/
      ctx[15]);
      attr(div, "data-ht21-pretty-date", div_data_ht___pretty_date_value = renderPrettyDate(
        /*date*/
        ctx[15]
      ));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*state*/
      16 && t0_value !== (t0_value = getDate(parseISO(
        /*date*/
        ctx2[15]
      )) + ""))
        set_data(t0, t0_value);
      if (dirty & /*state*/
      16 && div_class_value !== (div_class_value = "habit-tracker__cell habit-tracker__cell--" + getDayOfTheWeek(
        /*date*/
        ctx2[15]
      ))) {
        attr(div, "class", div_class_value);
      }
      if (dirty & /*state*/
      16 && div_data_ht___date_value !== (div_data_ht___date_value = /*date*/
      ctx2[15])) {
        attr(div, "data-ht21-date", div_data_ht___date_value);
      }
      if (dirty & /*state*/
      16 && div_data_ht___pretty_date_value !== (div_data_ht___pretty_date_value = renderPrettyDate(
        /*date*/
        ctx2[15]
      ))) {
        attr(div, "data-ht21-pretty-date", div_data_ht___pretty_date_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block2(ctx) {
  let habit_1;
  let current;
  habit_1 = new Habit_default({
    props: {
      name: (
        /*habit*/
        ctx[12].basename
      ),
      path: (
        /*habit*/
        ctx[12].path
      ),
      dates: (
        /*state*/
        ctx[4].computed.dates
      ),
      debug: (
        /*state*/
        ctx[4].settings.debug
      ),
      app: (
        /*app*/
        ctx[1]
      ),
      pluginName: (
        /*pluginName*/
        ctx[2]
      ),
      userSettings: (
        /*userSettings*/
        ctx[3]
      ),
      globalSettings: (
        /*globalSettings*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(habit_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(habit_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const habit_1_changes = {};
      if (dirty & /*state*/
      16)
        habit_1_changes.name = /*habit*/
        ctx2[12].basename;
      if (dirty & /*state*/
      16)
        habit_1_changes.path = /*habit*/
        ctx2[12].path;
      if (dirty & /*state*/
      16)
        habit_1_changes.dates = /*state*/
        ctx2[4].computed.dates;
      if (dirty & /*state*/
      16)
        habit_1_changes.debug = /*state*/
        ctx2[4].settings.debug;
      if (dirty & /*app*/
      2)
        habit_1_changes.app = /*app*/
        ctx2[1];
      if (dirty & /*pluginName*/
      4)
        habit_1_changes.pluginName = /*pluginName*/
        ctx2[2];
      if (dirty & /*userSettings*/
      8)
        habit_1_changes.userSettings = /*userSettings*/
        ctx2[3];
      if (dirty & /*globalSettings*/
      1)
        habit_1_changes.globalSettings = /*globalSettings*/
        ctx2[0];
      habit_1.$set(habit_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(habit_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(habit_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(habit_1, detaching);
    }
  };
}
function create_fragment2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*state*/
      ctx2[4].ui.fatalError
    )
      return 0;
    if (!/*state*/
    ctx2[4].computed.habits.length)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { pluginName } = $$props;
  let { globalSettings } = $$props;
  let { userSettings } = $$props;
  const createDefaultSettings = () => ({
    path: globalSettings.path,
    firstDisplayedDate: globalSettings.firstDisplayedDate || getDateAsString(subDays(new Date(), globalSettings.daysToShow - 1)),
    lastDisplayedDate: getDateAsString(new Date()),
    daysToShow: globalSettings.daysToShow,
    debug: globalSettings.debug,
    matchLineLength: globalSettings.matchLineLength
  });
  let state = {
    settings: createDefaultSettings(),
    computed: { dates: [], habits: [] },
    ui: {
      fatalError: "",
      rootElement: null,
      habitSource: null
    }
  };
  const init2 = function(userSettings2) {
    return __awaiter(this, void 0, void 0, function* () {
      if (userSettings2.path) {
        userSettings2.path = userSettings2.path.replace(/\/$/, "");
      }
      const hasExplicitFirstDate = userSettings2.firstDisplayedDate !== void 0;
      const hasExplicitLastDate = userSettings2.lastDisplayedDate !== void 0;
      const hasExplicitDaysToShow = userSettings2.daysToShow !== void 0;
      let resolvedSettings = {
        path: userSettings2.path || state.settings.path,
        lastDisplayedDate: userSettings2.lastDisplayedDate || state.settings.lastDisplayedDate,
        daysToShow: userSettings2.daysToShow !== void 0 ? userSettings2.daysToShow : state.settings.daysToShow,
        matchLineLength: userSettings2.matchLineLength !== void 0 ? userSettings2.matchLineLength : state.settings.matchLineLength,
        debug: userSettings2.debug !== void 0 ? userSettings2.debug : state.settings.debug
      };
      if (hasExplicitFirstDate) {
        resolvedSettings.firstDisplayedDate = userSettings2.firstDisplayedDate;
        if (hasExplicitLastDate) {
          const startDate = parseISO(userSettings2.firstDisplayedDate);
          const endDate = parseISO(userSettings2.lastDisplayedDate);
          resolvedSettings.daysToShow = eachDayOfInterval({ start: startDate, end: endDate }).length;
        }
      } else if (hasExplicitDaysToShow) {
        resolvedSettings.firstDisplayedDate = getDateAsString(subDays(parseISO(resolvedSettings.lastDisplayedDate), resolvedSettings.daysToShow - 1));
      } else {
        resolvedSettings.firstDisplayedDate = state.settings.firstDisplayedDate;
      }
      $$invalidate(4, state.settings = resolvedSettings, state);
      try {
        yield validateEssentials(state.settings);
      } catch (error) {
        $$invalidate(4, state.ui.fatalError = `Could not start: ${error.message}`, state);
        console.error(`[${pluginName}] ${state.ui.fatalError}`);
        return;
      }
      debugLog(state.settings, state.settings.debug);
      $$invalidate(
        4,
        state.computed.dates = eachDayOfInterval({
          start: parseISO(state.settings.firstDisplayedDate),
          end: parseISO(state.settings.lastDisplayedDate)
        }).map((date) => getDateAsString(date)),
        state
      );
      debugLog(`Will show habits for the following dates:`, state.settings.debug);
      debugLog(state.computed.dates, state.settings.debug);
      $$invalidate(4, state.computed.habits = getHabits(state.settings.path), state);
      if (state.computed.habits && state.computed.habits.length) {
        const count = state.computed.habits.length;
        debugLog(`Found ${count} ${pluralize(count, "habit")} at "${state.settings.path}" \u21B4`, state.settings.debug, void 0, pluginName);
        debugLog(state.computed.habits.map((habit) => habit.path), state.settings.debug, void 0, pluginName);
      } else {
        $$invalidate(4, state.ui.fatalError = `No habits found at "${state.settings.path}"`, state);
        debugLog(`No habits found at ${state.settings.path}`, state.settings.debug, void 0, pluginName);
        return;
      }
      debugLog(`Initialization completed successfully`, state.settings.debug);
    });
  };
  const scrollToEnd = function() {
    if (!state.ui.rootElement) {
      debugLog(`scrollToEnd: rootElement is null, cannot scroll`, state.settings.debug, void 0, pluginName);
      return;
    }
    const parent = state.ui.rootElement.parentElement;
    if (!parent) {
      debugLog(`scrollToEnd: parentElement is null, cannot scroll`, state.settings.debug, void 0, pluginName);
      return;
    }
    parent.scrollLeft = 99999999;
    debugLog(`scrollToEnd completed`, state.settings.debug);
  };
  const validateEssentials = function(settings) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!settings.path) {
        throw new Error("path is required - where should I load habits from?");
      }
      const source = app.vault.getAbstractFileByPath(settings.path);
      if (!source) {
        const mdSource = app.vault.getAbstractFileByPath(`${settings.path}.md`);
        if (!mdSource) {
          throw new Error(`"${settings.path}" doesn't exist in your vault`);
        }
      }
      debugLog(`Final settings are valid \u21B4`, state.settings.debug);
      return true;
    });
  };
  const getHabits = function(path) {
    debugLog(`Loading habits`, state.settings.debug);
    $$invalidate(4, state.ui.habitSource = app.vault.getAbstractFileByPath(path), state);
    if (state.ui.habitSource && state.ui.habitSource instanceof import_obsidian2.TFolder) {
      const allItems = state.ui.habitSource.children;
      const filesOnly = allItems.filter((item) => item instanceof import_obsidian2.TFile);
      const count = filesOnly.length;
      debugLog(`"${path}" points to a folder with ${count} ${pluralize(count, "file")} inside (ignoring subfolders)`, state.settings.debug, void 0, pluginName);
      const sortedFiles = filesOnly.sort((a, b) => a.basename.localeCompare(b.basename));
      return sortedFiles;
    }
    if (state.ui.habitSource && state.ui.habitSource instanceof import_obsidian2.TFile) {
      debugLog(`${path} points to a file`, state.settings.debug);
      return [state.ui.habitSource];
    }
    $$invalidate(4, state.ui.habitSource = app.vault.getAbstractFileByPath(`${path}.md`), state);
    if (state.ui.habitSource) {
      debugLog(`Adjusted ${path} to ${path}.md and found a file`, state.settings.debug, void 0, pluginName);
      return [state.ui.habitSource];
    }
    debugLog(`${path} is not found`, state.settings.debug);
    return [];
  };
  let refreshEventListener;
  onMount(() => {
    debugLog("Component mounted, setting up refresh listener");
    refreshEventListener = (event) => {
      console.log("[HabitTracker] Refresh event received:", event.detail.settings);
      $$invalidate(0, globalSettings = event.detail.settings);
      $$invalidate(4, state.settings = createDefaultSettings(), state);
      console.log("[HabitTracker] Reset state with new defaults:", state.settings);
      console.log("[HabitTracker] Calling init with updated settings");
      init2(userSettings);
    };
    document.addEventListener("habit-tracker-refresh", refreshEventListener);
    debugLog("Refresh event listener added to document");
  });
  onDestroy(() => {
    if (refreshEventListener) {
      document.removeEventListener("habit-tracker-refresh", refreshEventListener);
    }
  });
  init2(userSettings);
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      state.ui.rootElement = $$value;
      $$invalidate(4, state);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
    if ("pluginName" in $$props2)
      $$invalidate(2, pluginName = $$props2.pluginName);
    if ("globalSettings" in $$props2)
      $$invalidate(0, globalSettings = $$props2.globalSettings);
    if ("userSettings" in $$props2)
      $$invalidate(3, userSettings = $$props2.userSettings);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*state*/
    16) {
      $:
        if (state.ui.rootElement) {
          setTimeout(
            () => {
              scrollToEnd();
            },
            50
          );
        }
    }
  };
  return [globalSettings, app, pluginName, userSettings, state, div2_binding];
}
var HabitTracker = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      app: 1,
      pluginName: 2,
      globalSettings: 0,
      userSettings: 3
    });
  }
};
var HabitTracker_default = HabitTracker;

// src/HabitTrackerError.svelte
function create_fragment3(ctx) {
  let div1;
  let div0;
  let strong;
  let t0;
  let t1;
  let t2;
  let html_tag;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      strong = element("strong");
      t0 = text("\u{1F6D1} ");
      t1 = text(
        /*pluginName*/
        ctx[0]
      );
      t2 = space();
      html_tag = new HtmlTag(false);
      html_tag.a = null;
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, strong);
      append(strong, t0);
      append(strong, t1);
      append(div1, t2);
      html_tag.m(
        /*prettyError*/
        ctx[1],
        div1
      );
      ctx[7](div1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*pluginName*/
      1)
        set_data(
          t1,
          /*pluginName*/
          ctx2[0]
        );
      if (dirty & /*prettyError*/
      2)
        html_tag.p(
          /*prettyError*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      ctx[7](null);
    }
  };
}
function extractErrorPosition(errorMessage) {
  const match2 = errorMessage.match(/position (\d+)/);
  if (match2 && match2[1]) {
    return parseInt(match2[1], 10);
  }
  return -1;
}
function getFriendlyErrorMessage(errorMessage, jsonString, errorPosition) {
  if (errorMessage.includes("Unexpected token")) {
    if (jsonString[errorPosition - 1] === ",") {
      return "Error: Trailing comma found. Remove the comma after the last item in the settings.";
    } else {
      return `Error: Unexpected token at position ${errorPosition}. Check for missing commas, braces, or quotes.`;
    }
  }
  if (errorMessage.includes("Unexpected string")) {
    return `Error: Missing comma or extra comma at position ${errorPosition}. Check the syntax around this position.`;
  }
  if (errorMessage.includes("Unexpected number")) {
    return `Error: Missing comma at position ${errorPosition}. Add a comma between the items.`;
  }
  if (errorMessage.includes("Unexpected number")) {
    return `Error: Missing comma at position ${errorPosition}. Add a comma between the items.`;
  }
  const errorChar = jsonString.slice(errorPosition, errorPosition + 1);
  if (errorMessage.includes("Expected double-quoted property name in JSON at position") && errorChar == "}") {
    return "Error: Trailing comma found. Remove the comma after the last item in the settings.";
  } else {
    return `Error: ${errorMessage}`;
  }
}
function renderJsonWithError(jsonString, errorPosition, errorMessage) {
  const beforeError = jsonString.slice(0, errorPosition);
  const errorChar = jsonString.slice(errorPosition, errorPosition + 1);
  const afterError = jsonString.slice(errorPosition + 1);
  const highlightedErrorChar = `<span style="background-color: yellow; color: black;">${errorChar}</span>`;
  return `${errorMessage}<pre><code>user settings: ${beforeError}${highlightedErrorChar}${afterError}</code></pre>`;
}
function instance3($$self, $$props, $$invalidate) {
  let { error } = $$props;
  let { src } = $$props;
  let { pluginName } = $$props;
  let { app } = $$props;
  let { globalSettings } = $$props;
  let prettyError = "";
  let componentContainer;
  let refreshEventListener;
  function init2() {
    const errorPosition = extractErrorPosition(error.message);
    const errorMessage = getFriendlyErrorMessage(error.message, src, errorPosition);
    $$invalidate(1, prettyError = renderJsonWithError(src, errorPosition, errorMessage));
  }
  function attemptRecovery(updatedGlobalSettings) {
    console.log("[HabitTrackerError] Attempting recovery with new settings:", updatedGlobalSettings);
    try {
      const userSettings = JSON.parse(src);
      const habitTracker = new HabitTracker_default({
        target: componentContainer,
        props: {
          app,
          userSettings,
          globalSettings: updatedGlobalSettings,
          pluginName
        }
      });
      console.log("[HabitTrackerError] Recovery successful! Replacing error component.");
    } catch (newError) {
      console.log(
        "[HabitTrackerError] Recovery failed, still have error:",
        newError.message
      );
      if (newError.message !== error.message) {
        $$invalidate(3, error = newError);
        init2();
      }
    }
  }
  onMount(() => {
    console.log("[HabitTrackerError] Error component mounted, setting up refresh listener");
    refreshEventListener = (event) => {
      console.log("[HabitTrackerError] Refresh event received, attempting recovery");
      $$invalidate(4, globalSettings = event.detail.settings);
      attemptRecovery(globalSettings);
    };
    document.addEventListener("habit-tracker-refresh", refreshEventListener);
    console.log("[HabitTrackerError] Refresh event listener added to document");
  });
  onDestroy(() => {
    if (refreshEventListener) {
      document.removeEventListener("habit-tracker-refresh", refreshEventListener);
      console.log("[HabitTrackerError] Refresh event listener removed");
    }
  });
  init2();
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      componentContainer = $$value;
      $$invalidate(2, componentContainer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("error" in $$props2)
      $$invalidate(3, error = $$props2.error);
    if ("src" in $$props2)
      $$invalidate(5, src = $$props2.src);
    if ("pluginName" in $$props2)
      $$invalidate(0, pluginName = $$props2.pluginName);
    if ("app" in $$props2)
      $$invalidate(6, app = $$props2.app);
    if ("globalSettings" in $$props2)
      $$invalidate(4, globalSettings = $$props2.globalSettings);
  };
  return [
    pluginName,
    prettyError,
    componentContainer,
    error,
    globalSettings,
    src,
    app,
    div1_binding
  ];
}
var HabitTrackerError = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      error: 3,
      src: 5,
      pluginName: 0,
      app: 6,
      globalSettings: 4
    });
  }
};
var HabitTrackerError_default = HabitTrackerError;

// src/main.ts
var DEFAULT_SETTINGS = {
  path: "",
  daysToShow: 21,
  debug: false,
  matchLineLength: true,
  defaultColor: "",
  showStreaks: true
};
var HabitTracker21 = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerMarkdownCodeBlockProcessor("habittracker", async (src, el) => {
      debugLog("Loading", 1);
      let userSettings = {};
      try {
        userSettings = JSON.parse(src);
        const debugMode = this.settings.debug || userSettings.debug;
        debugLog(`Global settings: ${JSON.stringify(this.settings)}`, debugMode);
        debugLog(`Tracker settings: ${JSON.stringify(userSettings)}`, debugMode);
        debugLog(`Today is ${format(new Date(), "yyyy-MM-dd")}`, debugMode);
        new HabitTracker_default({
          target: el,
          props: {
            app: this.app,
            userSettings,
            globalSettings: this.settings,
            pluginName: this.manifest.name
          }
        });
      } catch (error) {
        new HabitTrackerError_default({
          target: el,
          props: {
            error,
            src,
            pluginName: this.manifest.name,
            app: this.app,
            globalSettings: this.settings
          }
        });
        console.error(`[${this.manifest.name}] Received invalid settings. ${error}`);
      }
    });
    this.addHoverActionBars();
    setTimeout(() => this.checkForUpdatesBackground(), 5e3);
    this.addSettingTab(new HabitTrackerSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    console.log("[HabitTracker] Saving settings:", this.settings);
    await this.saveData(this.settings);
    this.refreshAllHabitTrackers();
  }
  refreshAllHabitTrackers() {
    console.log("[HabitTracker] Dispatching refresh event with settings:", this.settings);
    const refreshEvent = new CustomEvent("habit-tracker-refresh", {
      detail: { settings: this.settings }
    });
    document.dispatchEvent(refreshEvent);
    console.log("[HabitTracker] Refresh event dispatched");
  }
  addHoverActionBars() {
    document.addEventListener("mouseover", (e) => {
      const target = e.target;
      if (!target || typeof target.closest !== "function")
        return;
      const codeBlock = target.closest(".cm-lang-habittracker");
      if (codeBlock && !codeBlock.querySelector(".ht21-action-bar")) {
        this.checkForUpdatesBackground();
        const actionBar = this.createActionBar(codeBlock);
        codeBlock.appendChild(actionBar);
      }
    });
    document.addEventListener("mouseleave", (e) => {
      const target = e.target;
      if (!target || typeof target.closest !== "function")
        return;
      const codeBlock = target.closest(".cm-lang-habittracker");
      if (codeBlock) {
        setTimeout(() => {
          if (!codeBlock.matches(":hover")) {
            const actionBar = codeBlock.querySelector(".ht21-action-bar");
            actionBar == null ? void 0 : actionBar.remove();
          }
        }, 100);
      }
    });
  }
  // TODO could we do this with Svelte?
  createActionBar(codeBlock) {
    const actionBar = document.createElement("div");
    actionBar.className = "ht21-action-bar";
    const storedVersion = localStorage.getItem("habit-tracker-update-available");
    const currentVersion = this.manifest.version;
    const hasUpdate = storedVersion && storedVersion !== currentVersion;
    const updateDot = hasUpdate ? '<span class="ht21-update-dot"></span>' : "";
    const tooltipText = hasUpdate ? "New version available" : "Check for updates";
    actionBar.innerHTML = `
			<span class="ht21-action-bar__title">${this.manifest.name}</span>
			<div class="ht21-action-bar__buttons">
				<button class="clickable-icon ht21-action-bar__btn--update" aria-label="${tooltipText}" style="position: relative;"><span class="ht21-btn-text">Updates</span>${updateDot}</button>
				<button class="clickable-icon ht21-action-bar__btn--edit" aria-label="Edit this block"><span class="ht21-btn-text">Edit this block</span></button>
				<button class="clickable-icon ht21-action-bar__btn--settings" aria-label="Plugin Settings"><span class="ht21-btn-text">Plugin Settings</span></button>
			</div>
		`;
    const settingsBtn = actionBar.querySelector(".ht21-action-bar__btn--settings");
    const updateBtn = actionBar.querySelector(".ht21-action-bar__btn--update");
    const editBtn = actionBar.querySelector(".ht21-action-bar__btn--edit");
    if (settingsBtn)
      (0, import_obsidian3.setIcon)(settingsBtn, "settings");
    if (updateBtn)
      (0, import_obsidian3.setIcon)(updateBtn, "download");
    if (editBtn)
      (0, import_obsidian3.setIcon)(editBtn, "lucide-code-2");
    settingsBtn == null ? void 0 : settingsBtn.addEventListener("click", () => this.openSettings());
    updateBtn == null ? void 0 : updateBtn.addEventListener("click", () => {
      localStorage.removeItem("habit-tracker-update-available");
      localStorage.removeItem("habit-tracker-last-update-check");
      if (hasUpdate) {
        this.openCommunityPlugins();
      } else {
        this.checkForUpdates();
      }
    });
    editBtn == null ? void 0 : editBtn.addEventListener("click", () => this.editBlock(codeBlock));
    return actionBar;
  }
  openSettings() {
    this.app.setting.open();
    this.app.setting.openTabById(this.manifest.id);
  }
  openCommunityPlugins() {
    window.open("obsidian://show-plugin?id=habit-tracker-21");
  }
  async checkForUpdates() {
    await this.performUpdateCheck();
  }
  async checkForUpdatesBackground() {
    const lastCheck = localStorage.getItem("habit-tracker-last-update-check");
    const now2 = Date.now();
    const dayInMs = 24 * 60 * 60 * 1e3;
    if (lastCheck && now2 - parseInt(lastCheck) < dayInMs) {
      return;
    }
    await this.performUpdateCheck();
  }
  async performUpdateCheck() {
    try {
      const response = await fetch("https://api.github.com/repos/zincplusplus/habit-tracker/releases/latest");
      if (!response.ok)
        throw new Error("Failed to fetch");
      const latestRelease = await response.json();
      const latestVersion = latestRelease.tag_name.replace("v", "");
      const currentVersion = this.manifest.version;
      localStorage.setItem("habit-tracker-last-update-check", Date.now().toString());
      console.log("Debug - latestVersion:", latestVersion);
      console.log("Debug - currentVersion:", currentVersion);
      const isNewer = this.isNewerVersion(latestVersion, currentVersion);
      console.log("Debug - isNewerVersion result:", isNewer);
      if (isNewer) {
        localStorage.setItem("habit-tracker-update-available", latestVersion);
        console.log("Debug - Stored update available:", latestVersion);
      } else {
        console.log("Debug - No update needed, removing localStorage entry");
        localStorage.removeItem("habit-tracker-update-available");
      }
    } catch (error) {
      console.log("Update check failed:", error);
    }
  }
  isNewerVersion(latest, current) {
    const parseVersion = (v) => v.split(".").map(Number);
    const latestParts = parseVersion(latest);
    const currentParts = parseVersion(current);
    for (let i = 0; i < Math.max(latestParts.length, currentParts.length); i++) {
      const l = latestParts[i] || 0;
      const c = currentParts[i] || 0;
      if (l > c)
        return true;
      if (l < c)
        return false;
    }
    return false;
  }
  editBlock(codeBlock) {
    const editButton = codeBlock.querySelector(".edit-block-button");
    if (editButton) {
      editButton.click();
    } else {
    }
  }
  onunload() {
  }
};
var HabitTrackerSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: `${this.plugin.manifest.name} Settings` });
    let generalHeader = containerEl.createEl("h4", { text: "General Settings" });
    generalHeader.style.marginBottom = "0";
    const generalDesc = containerEl.createEl("div", {
      cls: "setting-item-description",
      text: "These apply to all trackers and can be overridden either in the codeblock or in the habit tracker file."
    });
    generalDesc.style.marginBottom = "15px";
    generalDesc.style.fontSize = "0.85em";
    generalDesc.style.color = "var(--text-muted)";
    new import_obsidian3.Setting(containerEl).setName("Default path").setDesc('Default path for habits (folder or file). Can be overridden with "path" in code blocks.').addDropdown((dropdown) => {
      const folders = this.app.vault.getAllLoadedFiles().filter((file) => "children" in file && file.children !== void 0).map((folder) => folder.path).sort();
      folders.forEach((folderPath) => {
        dropdown.addOption(folderPath, folderPath);
      });
      dropdown.setValue(this.plugin.settings.path);
      dropdown.onChange(async (value) => {
        this.plugin.settings.path = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Days to show").setDesc('Number of days to display in the habit tracker. Can be overridden with "daysToShow" in code blocks.').addText((text2) => text2.setValue(this.plugin.settings.daysToShow.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.daysToShow = numValue;
        await this.plugin.saveSettings();
      }
    })).then((setting) => {
      const inputEl = setting.controlEl.querySelector("input");
      if (inputEl) {
        inputEl.type = "number";
        inputEl.min = "1";
        inputEl.step = "1";
      }
    });
    new import_obsidian3.Setting(containerEl).setName("Default color").setDesc('Default habit color (hex, RGB, or CSS color name). Can be overridden with "color" in code blocks or habit frontmatter.').addText((text2) => text2.setValue(this.plugin.settings.defaultColor).setPlaceholder("#4CAF50 or green").onChange(async (value) => {
      if (!value || isValidCSSColor(value)) {
        this.plugin.settings.defaultColor = value;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian3.Setting(containerEl).setName("Show streaks").setDesc('Display streak indicators and counts. Can be overridden with "showStreaks" in code blocks.').addToggle((toggle) => toggle.setValue(this.plugin.settings.showStreaks).onChange(async (value) => {
      this.plugin.settings.showStreaks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Match line length").setDesc('Make habit tracker match the width of the readable line length. Can be overridden with "matchLineLength" in code blocks.').addToggle((toggle) => toggle.setValue(this.plugin.settings.matchLineLength).onChange(async (value) => {
      this.plugin.settings.matchLineLength = value;
      await this.plugin.saveSettings();
    }));
    const troubleshootingHeader = containerEl.createEl("h4", { text: "Troubleshooting" });
    troubleshootingHeader.style.marginTop = "30px";
    new import_obsidian3.Setting(containerEl).setName("Debug mode").setDesc('Enable debug output to console. Can be overridden with "debug" in code blocks.').addToggle((toggle) => toggle.setValue(this.plugin.settings.debug).onChange(async (value) => {
      this.plugin.settings.debug = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Reset settings").setDesc("Reset all settings to their default values").addButton((button) => button.setButtonText("Reset to defaults").setWarning().onClick(async () => {
      this.plugin.settings = Object.assign({}, DEFAULT_SETTINGS);
      await this.plugin.saveSettings();
      this.display();
    }));
  }
};

/* nosourcemap */